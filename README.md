# Разработка сетевого приложения на C#

### Работа с сетью: чтение и запись данных в сеть. Клиентские и серверные приложения
- **Задача:** Попробуйте переработать приложение, добавив подтверждение об отправке сообщений как в сервер, так и в клиент.
- **Исполнение:** Сделано по примеру работы на семинаре.
- **Коммит:** dababd4e0e60b5f6c2d1459600184da881176df6

### Синхронизации: многопоточность, создание и завершение потоков
- **Задача:** Добавьте возможность ввести слово Exit в чате клиента, чтобы можно было завершить его работу. В коде сервера добавьте ожидание нажатия клавиши, чтобы также прекратить его работу.
- **Исполнение:** Разделила клиент и сервер (два класса), сделала их не статичными (в отличие от примеров на семинаре).
- **Коммит:** 7f390fe8ca62b4a7291f376cb2526d92701aae8b

### PLINQ и асинхронность: как работает, области применения
- **Задача:** Добавьте использование Cancellationtoken в код сервера, чтобы можно было правильно останавливать работу сервера.
- **Исполнение:** Теперь всё async.
- **Коммит:** 51079c594e17d5973fe9617797f2e8f6763d3390

### GOF: паттерны проектирования в .Net разработке
- **Задача:** Структурируйте код клиента и сервера чата, используя знания о шаблонах.
- **Исполнение:** Попробовала реализовать паттерн builder. 
- **Коммит:** 6829893cd47eea88c8a51ce2e1b8e6d411d9f351

### Базы данных: Entity framework, code first/db first
- **Задача:** Реализуйте тип сообщений List, при котором клиент будет получать все непрочитанные сообщения с сервера.
- **Исполнение:** Добавлена работа с базой данных (postgresql). Первое проектирование. Code first.
- **Коммит:** b626329e0faf0094d79d2219c9060d3c934da33a

### Тестирование приложений: test driven development
- **Задача:** Продумайте, как можно протестировать код клиента по аналогии с кодом сервера.
- **Исполнение:** Выбрала MSTest. 
- **Коммит:** 3f157b94e2fa1cb33afee06cfa1d8f4cea778fd2

### Библиотеки: Nuget и разработка собственных библиотек
- **Задача:** Доработайте чат, заменив UDP-сокеты на NetMQ. Для этого напишите новую библиотеку, где в которой вы имплементируется IMessageSource и IMessageSourceClient с применением указанной библиотеки.
- **Исполнение:** На момент выполнения задачи захотелось попробовать поразбивать проект на библиотеки, что я и сделала. И ещё попробовала не заменить работу с UDP полностью, а как бы решила добавить NetMQ, чтобы иметь возможность менять одно на другое. В итоге из-за того, что NetMQ работает на TCP и нам не нужно самостоятельно реализовывать подтверждение достаки, получается, что они не могут заменять друг друга на самом деле. Но так как мы проходили dependency injection, мне показалось странным, что мы написали интерфейс и по сути можем подменять реализацию, но при этом - на самом деле не можем из-за протоколов. Поэтому я наколдовала так, что оба варианта работают, хотя понимаю, что они на самом деле не равноправны. В течение всех семинаров были вопросы, почему мы выбрали именно UDP, возможно, цель в том, чтобы мы сами делали методы подтверждения доставки. Также добавлю, что NetMQ имеет ограниченный набор сокетов и за время, которое я имела на выполнение дз, я прочитала всё, что смогла о них, но многое вызывало вопросы. Например, вроде как библиотека позволяет использовать асинхронность (асинхронные версии методов), но при этом просит использовать некий NetMQRuntime и добавлять методы в список, чтобы запускать. Но при этом они работают синхронно, и чтобы они были асинхронными нужно использовать Task.Run и обычные версии методов. Может, я что-то пока не понимаю, но надеюсь когда-нибудь разобраться. Также из каждого сокета доступны все виды отправок сообщений, тогда как на деле можно использовать определенные. Другие нельзя. Почему? Как реализованы классы сокетов? Почему методы доступны в подсказках VS, но использовать нельзя? "Посылка есть, вот только я вам ее не отдам. У вас документов нет.". Из-за отсутствия опыта работы с подобными библиотеками и непониманием того, как реализовать общение типа "клиент шлет серверу, сервер шлет подтверждение отправителю и само сообщение от клиента переадресовывает списку клиентов" - долго думала и решила использовать по паре сокетов со стороны клиентов и сервера. Клиенты были dealer (для направления запроса серверу) и subscriber (для получения рассылки), сервер был router (для приема запросов на добавление в чат) и publisher (для рассылки). Никаких комментариев от преподавателя, к сожалению, не получала на протяжении всех работы, поэтому оценивать себя могла только самостоятельно.
- **Коммит:** 02941a1b2d2401e0bf715a98b1ac6068acd50166  

**P.S.** Точка входа в программу в папке **HomeworkGB9**.
